# SCTLR_EL2 (系统控制寄存器)

在 EL2 上提供对系统（包括其内存系统）的顶层控制。当FEAT_VHE实施时，[HCR_EL2](https://developer.arm.com/documentation/ddi0595/2021-06/AArch64-Registers/HCR-EL2--Hypervisor-Configuration-Register?lang=en)的值。{E2H， TGE} 是 {1， 1}，这些控制也适用于 EL0 的执行。



## 配置

AArch64 系统寄存器 SCTLR_EL2 的低 32 位（bit [31:0]）在架构上被映射到了 AArch32 系统寄存器 HSCTLR 的低 32 位（bit [31:0]）。

如果 EL2 没有被实现，那么在 EL3 中，这个寄存器的值是保留的（RES0），即没有定义具体的值。

如果在当前安全状态下 EL2 没有被启用，这个寄存器将不会产生任何效果。

## 属性

SCTLR_EL2 是一个 64 位的寄存器。



## 字段说明

![image-20240729101445993](D:\Desktop\Note\ARM寄存器\assets\image-20240729101445993.png)

### TIDCP，bit [63]

当实现了FEAT_TIDCP1和HCR_EL2.E2H == 1:

捕获 [^IMPLEMENTATION DEFINED] 功能。捕获 EL0 访问那些为 IMPLEMENTATION DEFINED 功能预留的编码到 EL2。

| TIDCP | 含义                                                         |
| ----- | ------------------------------------------------------------ |
| 0b0   | No instructions accessing the System register or System instruction spaces are trapped by this mechanism. |
|       | 如果 HCR_EL2.TGE==0，则此机制不会捕获访问系统寄存器或系统指令空间的指令。 |
|       | 如果 HCR_EL2.TGE==1，则以下系统寄存器或系统指令空间的访问将被此机制捕获到 EL2： |
|       | - 在 AArch64 状态下，EL0 对以下保留编码空间的访问被捕获：    |
|       | - 使用 SYS 和 SYSL 访问的实现定义系统指令，使用 CRn == {11, 15}，并使用 EC 综合征 0x18 报告。 |
|       | - 使用 SYSP 访问的实现定义系统指令，使用 CRn == {11, 15}，并使用 EC 综合征 0x14 报告。 |
| 0b1   | - 使用 MRS 和 MSR 访问的实现定义系统寄存器，使用 S3\_\<op1>\_\<Cn>\_\<Cm>\_\<op2> 注册名，并使用 EC 综合征 0x18 报告。 |
|       | - 使用 MRRS 和 MSRR 访问的实现定义系统寄存器，使用 S3\_\<op1>*\<Cn>*\<Cm>_\<op2> 注册名，并使用 EC 综合征 0x14 报告。 |
|       | - 在 AArch32 状态下，EL0 MRC 和 MCR 对以下编码的访问被捕获，并使用 EC 综合征 0x03 报告： |
|       | - coproc\==p15，CRn==c9，opc1 == {0-7}，CRm == {c0-c2, c5-c8}，opc2 == {0-7}。 |
|       | - coproc\==p15，CRn==c10，opc1 =={0-7}，CRm == {c0, c1, c4, c8}，opc2 == {0-7}。 |
|       | - coproc\==p15，CRn==c11，opc1={0-7}，CRm == {c0-c8, c15}，opc2 == {0-7}。 |

如果 HCR_EL2.TGE 的值为 0b0，则除了对该寄存器的直接读写操作外，该字段在所有其他目的中都将被忽略。

该字段的复位行为如下：

- 在温复位（Warm reset）的情况下，如果处理器元素（PE）复位进入 EL2，则该字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### SPINTMASK，bit [62]
当 `FEAT_NMI` 被实现时：

SP 中断屏蔽使能。当 `SCTLR_EL2.NMI` 为 1 时，控制 PSTATE.SP 是否作为中断屏蔽，并控制在进入 EL2 异常时 PSTATE.ALLINT 的值。

| SPINTMASK | 含义                                                         |
| --------- | ------------------------------------------------------------ |
| 0b0       | 不导致 PSTATE.SP 掩码中断。                                  |
|           | 在进入 EL2 时，PSTATE.ALLINT 设置为 1。                      |
| 0b1       | 当 PSTATE.SP 为 1 并且执行在 EL2 时，无论是否有超优先级标记，针对 EL2 的 IRQ 或 FIQ 中断都会被屏蔽。 |
|           | 在进入 EL2 时，PSTATE.ALLINT 设置为 0。                      |

该字段的复位行为如下：

- 在温复位（Warm reset）的情况下，如果处理器元素（PE）复位进入 EL2，则该字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### NMI，bit [61]

当 `FEAT_NMI` 被实现时： 非掩蔽中断使能。

| NMI  | 含义                                                 |
| ---- | ---------------------------------------------------- |
| 0b0  | 此控制不影响中断屏蔽行为。                           |
| 0b1  | 开启以下所有功能：                                   |
|      | - 使用 PSTATE.ALLINT 中断屏蔽。                      |
|      | - 将 IRQ 和 FIQ 中断设置为具有超级优先级的附加属性。 |
|      | - 使用 PSTATE.SP 作为中断屏蔽。                      |

该字段的复位行为如下： 

- 在温复位（Warm reset）的情况下，如果处理器元素（PE）复位进入 EL2，则该字段复位为 `0`。

在其他情况下：

- 保留，RES0。



### ENTP2，bit [60]

当 `FEAT_SME` 被实现并且 `HCR_EL2.E2H` 的有效值为 1 时： 在当前安全状态下，当实现了 EL2 并且启用时，捕获在 EL0 执行访问 `TPIDR2_EL0` 到 EL2 的指令。异常使用 ESR_ELx.EC 值 0x18 报告。

| ENTP2 | 含义                                    |
| ----- | --------------------------------------- |
| 0b0   | 该控制导致这些指令在 EL0 处于陷阱状态。 |
| 0b1   | 该控制不导致任何指令处于陷阱状态。      |

如果 `HCR_EL2.TGE` 等于 `0b0`，则除了对该寄存器的直接读写操作外，该字段在所有其他目的中都被忽略。

该字段的复位行为如下： 

- 在温复位（Warm reset）的情况下，如果处理器元素（PE）复位进入 EL2，则该字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### TCSO，bit [59]

当 `FEAT_MTE_STORE_ONLY` 被实现时： 标签检查存储仅限。

| TCSO | 含义                              |
| ---- | --------------------------------- |
| 0b0  | 对标签检查没有影响。              |
| 0b1  | 在 EL2 执行的加载指令未检查标签。 |

该字段的复位行为如下： 

- 在温复位（Warm reset）的情况下，如果处理器元素（PE）复位进入 EL2，则该字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### TCSO0，bit [58]

当 `FEAT_MTE_STORE_ONLY` 被实现并且 `HCR_EL2.E2H` 的有效值为 1 时： 在 EL0 标签检查存储仅限。

| TCSO0 | 含义                              |
| ----- | --------------------------------- |
| 0b0   | 对标签检查没有影响。              |
| 0b1   | 在 EL0 执行的加载指令未检查标签。 |

如果 `HCR_EL2.TGE` 等于 `0b0`，则除了对该寄存器的直接读写操作外，该字段被忽略。

该字段的复位行为如下： 

- 在温复位（Warm reset）的情况下，如果处理器元素（PE）复位进入 EL2，则该字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### EPAN，bit [57]

当 FEAT_PAN3 执行时, HCR_EL2.E2H == 1 和 HCR_EL2.TGE == 1的时候:

增强的特权访问。当PSTATE. SPAN为1时，确定对具有EL 0指令访问权限的页面的EL 2数据访问是否会因特权访问从不机制而生成权限错误。 

| EPAN | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0b0  | 此机制不会生成额外的权限错误。                               |
| 0b1  | 对具有第1阶段EL0数据访问权限或第1阶段EL0指令访问权限的页面进行EL2数据访问将生成权限错误。<br/>如果访问不是推测性的，任何将生成权限错误的推测性数据访问都不会导致分配到缓存中。 |

允许将此位缓存在TSB中。 

此字段的重置行为为： 

- 在温复位（Warm reset）时，在PE重置为EL 2的系统中，该字段重置为体系结构未知的值。 

在其他情况下：

- 保留，RES0。



### EnALS，bit [56]

当实现了FEAT_LS64时，HCR_EL2.E2H == 1和HCR_EL2.TGE == 1:

在EL0到EL2处捕获LD64B或ST64B指令的执行。

| EnALS | 解释                                       |
| ----- | ------------------------------------------ |
| 0b0   | 在EL0处执行LD64B或ST64B指令会被捕获到EL2。 |
| 0b1   | 此控制不会导致任何指令被捕获。             |

使用ESR_ELx报告LD64B或ST64B指令的陷阱。EC值为0x0A, ISS代码为0x0000002。

该字段的重置行为为:

- 在Warm复位时，在PE复位为EL2的系统中，该字段复位为架构上的UNKNOWN值。

在其他情况下：

- 保留，RES0。



### EnAS0，bit [55]

当 `FEAT_LS64_ACCDATA` 被实现并且 `HCR_EL2.E2H` 的有效值为 1 时： 捕获在 EL0 执行的 `ST64BV0` 指令到 EL2。

| EnAS0 | 含义                                       |
| ----- | ------------------------------------------ |
| 0b0   | 在 EL0 执行的 `ST64BV0` 指令被捕获到 EL2。 |
| 0b1   | 该控制不会导致任何指令被捕获。             |

如果 `HCR_EL2.TGE` 等于 `0b0`，则除了对该寄存器的直接读写操作外，该字段被忽略。 一个 `ST64BV0` 指令的捕获通过具有 `ESR_ELx.EC` 值 0x0A 和 `ISS` 代码 0x00000001 来报告。

该字段的复位行为如下： 

- 在温复位（Warm reset）的情况下，如果处理器元素（PE）复位进入 EL2，则该字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### EnASR, bit [54]

当 `FEAT_LS64_V` 被实现并且 `HCR_EL2.E2H` 的有效值为 1 时： 捕获在 EL0 执行的 `ST64BV` 指令到 EL2。

| EnASR | 含义                                      |
| ----- | ----------------------------------------- |
| 0b0   | 在 EL0 执行的 `ST64BV` 指令被捕获到 EL2。 |
| 0b1   | 该控制不会导致任何指令被捕获。            |

如果 `HCR_EL2.TGE` 等于 `0b0`，则除了对该寄存器的直接读写操作外，该字段被忽略。 一个 `ST64BV` 指令的捕获通过具有 `ESR_ELx.EC` 值 0x0A 和 `ISS` 代码 0x00000000 来报告。

该字段的复位行为如下： 

- 在温复位（Warm reset）的情况下，如果处理器元素（PE）复位进入 EL2，则该字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### TME, bit [53]

当 `FEAT_TME` 被实现时： 启用 EL2 的事务性内存扩展。

| TME  | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0b0  | 在 EL2 执行任何尝试执行 `TSTART` 指令都会被捕获，除非 `HCR_EL2.TME` 或 `SCR_EL3.TME` 导致 `TSTART` 指令在 EL2 上变为未定义。 |
| 0b1  | 该控制不会导致任何 `TSTART` 指令被捕获。                     |

该字段的复位行为如下： 

- 在温复位（Warm reset）的情况下，如果处理器元素（PE）复位进入 EL2，则该字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### TME0, bit [52]

当 `FEAT_TME` 被实现并且 `HCR_EL2.E2H` 的有效值为 1 时： 启用 EL0 的事务性内存扩展。

| TME0 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0b0  | 在 EL0 执行任何尝试执行 `TSTART` 指令会被捕获到 EL2，除非 `HCR_EL2.TME` 或 `SCR_EL3.TME` 导致 `TSTART` 指令在 EL0 上变为未定义。 |
| 0b1  | 该控制不会导致任何 `TSTART` 指令被捕获。                     |

如果 `HCR_EL2.TGE` 等于 `0b0`，则除了对该寄存器的直接读写操作外，该字段被忽略。 

该字段的复位行为如下： 

- 在温复位（Warm reset）的情况下，如果处理器元素（PE）复位进入 EL2，则该字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### TMT, bit [51]

当 `FEAT_TME` 被实现时： 强制在 EL2 上实施简单的事务性内存扩展。

| TMT  | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0b0  | 该控制不会导致任何 `TSTART` 指令失败。                       |
| 0b1  | 当在 EL2 执行 `TSTART` 指令时，交易以 TRIVIAL 失败原因失败。 |

该字段的复位行为如下： 

- 在温复位（Warm reset）的情况下，如果处理器元素（PE）复位进入 EL2，则该字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### TMT0, bit [50]

当 `FEAT_TME` 被实现且 `HCR_EL2.E2H` 的有效值为 1 时： 强制在 EL0 上实施简单的事务性内存扩展。

| TMT0 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0b0  | 该控制不会导致任何 `TSTART` 指令失败。                       |
| 0b1  | 当在 EL0 执行 `TSTART` 指令时，交易以 TRIVIAL 失败原因失败。 |

如果 `HCR_EL2.TGE` 等于 `0b0`，则除了对该寄存器的直接读写操作外，该字段被忽略。 

该字段的复位行为如下： 

- 在温复位（Warm reset）的情况下，如果处理器元素（PE）复位进入 EL2，则该字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### TWEDEL, bits [49:46]

当 `FEAT_TWED` 被实现且 `HCR_EL2.E2H` 的有效值为 1 时： 编码了由 SCTLR_EL2.nTWE 引起的 WFE 被捕获的最小延迟，形式为 $2^{TWEDEL+8}$ 周期。

如果 `HCR_EL2.TGE` 等于 `0b0`，则除了对该寄存器的直接读写操作外，该字段被忽略。 

该字段的复位行为如下： 

- 在温复位（Warm reset）的情况下，如果处理器元素（PE）复位进入 EL2，则该字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### TWEDEn, bit [45]

当 `FEAT_TWED` 被实现且 `HCR_EL2.E2H` 的有效值为 1 时： 启用可配置的 WFE 指令延迟陷阱。

| TWEDEn | 含义                                                 |
| ------ | ---------------------------------------------------- |
| 0b0    | WFE 延迟陷阱的实现定义。                             |
| 0b1    | WFE 延迟陷阱至少为 SCTLR_EL2.TWEDEL 中定义的周期数。 |

如果 `HCR_EL2.TGE` 等于 `0b0`，则除了对该寄存器的直接读写操作外，该字段被忽略。 

该字段的复位行为如下： 

- 在温复位（Warm reset）的情况下，如果处理器元素（PE）复位进入 EL2，则该字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### DSSBS, bit [44]

当 `FEAT_SSBS` 被实现时： 默认 PSTATE.SSBS 在异常进入时的值。

| DSSBS | 含义                                    |
| ----- | --------------------------------------- |
| 0b0   | 异常进入 EL2 时，PSTATE.SSBS 设置为 0。 |
| 0b1   | 异常进入 EL2 时，PSTATE.SSBS 设置为 1。 |

该字段的复位行为如下： 

- 在温复位（Warm reset）情况下，该字段重设为实施定义的值。

在其他情况下：

- 保留，RES0。



### ATA, bit [43]

当 `FEAT_MTE2` 被实现时： 

EL2 分配标签访问。

当 `SCR_EL3.ATA` 为 1 时，在 EL2 控制分配标签和标签检查操作。

| ATA  | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0b0  | 防止在 EL2 访问分配标签。EL2 内存访问不受标签检查操作影响。  |
| 0b1  | 此控制不阻止在 EL2 访问分配标签。EL2 标签检查内存访问受标签检查操作影响。根据所访问内存的标签类型进行不同的标签检查操作：对于分配标记内存，执行分配标签检查操作；如果实现了 `FEAT_MTE_CANONICAL_TAGS`，对于规范性标记内存，执行规范标签检查操作。 |

该字段的复位行为如下： 

- 在温复位（Warm reset）的情况下，如果处理器元素（PE）复位进入 EL2，则该字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### ATA0, bit [42]

当 `FEAT_MTE2` 被实现且 `HCR_EL2.E2H` 的有效值为 1 时： 

EL0 分配标签访问。

当 `SCR_EL3.ATA` 为 1 时，在 EL0 控制分配标签和标签检查操作。

| ATA0 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0b0  | 防止在 EL0 访问分配标签。EL0 内存访问不受标签检查操作影响。  |
| 0b1  | 此控制不阻止在 EL0 访问分配标签。EL0 标签检查内存访问受标签检查操作影响。根据所访问内存的标签类型进行不同的标签检查操作：对于分配标记内存，执行分配标签检查操作；如果实现了 `FEAT_MTE_CANONICAL_TAGS`，对于规范性标记内存，执行规范标签检查操作。 |

如果 `HCR_EL2.TGE` 等于 0b0，则除了直接读写寄存器外，该字段被忽略。

```
软件可以在上下文切换时更改此控制位。
```

该字段的复位行为如下： 

- 在温复位（Warm reset）的情况下，如果处理器元素（PE）复位进入 EL2，则该字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### TCF，bits [41：40]

当**FEAT_MTE2**实现时：

控制在EL2中由于加载和存储导致的标签检查故障的影响。

| TCF    | 含义                                                   | 适用条件               |
| ------ | ------------------------------------------------------ | ---------------------- |
| `0b00` | 标签检查故障对PE没有影响。                             | -                      |
| `0b01` | 标签检查故障导致同步异常。                             | -                      |
| `0b10` | 标签检查故障被异步累积。                               | -                      |
| `0b11` | 在读取时标签检查故障导致同步异常，在写入时被异步累积。 | 当实施 FEAT_M3实施时。 |

如果未实现**FEAT_MTE3**，则值`0b11`是保留的。

此字段的复位行为如下：

- 在温复位（Warm reset）时，在系统中PE重置到EL2，该字段将重置为架构上未知的值。

在其他情况下：

- 保留，RES0。



### TCFO，bits [39:38]

当 FEAT_ MTE2 被实现且 HCR_EL2.E2H 的有效值为 1 时：

在 EL0 中的标签检查故障。控制由于负载和存储在 EL0 导致的标签检查故障的影响。

| TCFO | 含义                                                   | 适用条件               |
| ---- | ------------------------------------------------------ | ---------------------- |
| 0b00 | 标签检查故障对 PE 没有任何影响。                       | -                      |
| 0b01 | 标签检查故障引发同步异常。                             | -                      |
| 0b10 | 标签检查故障被异步累积。                               | -                      |
| 0b11 | 在读取时标签检查故障引发同步异常，在写入时被异步累积。 | 当实施 FEAT_M3实施时。 |

如果未实施 FEAT_MTE3，则值 0b11 保留。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### ITFSB，bit [37]

当实施了FEAT_MTE2时：

当标签检查故障不产生同步异常时，此字段控制是否在进入EL2时同步所有在异常进入之前执行的指令报告的异步标签检查故障到TFSREO_EL1、TFSR_EL1和TFSR_EL2寄存器。

| ITFSB | 含义                          |
| ----- | ----------------------------- |
| 0b0   | 进入EL2时不同步标签检查故障。 |
| 0b1   | 进入EL2时同步标签检查故障。   |

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### BT，bit [36]

当实施了FEAT_BTI时：

指示以下指令在 EL2 的隐式BTI行为的分支类型兼容性：

- PACIASP。
- PACIBSP。
- 如果实现了FEAT_PAuth_LR，则为PACIASPPC。
- 如果实现了FEAT_PAuth_LR，则为PACIBSPPC。

当 HCR_EL2.[E2H, TGE] 的有效值为 {1, 1} 时，此位称为 BT1。

| BT   | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0b0  | 当 PE 在 EL2 执行时，指定的指令具有隐式 BTI 行为，它们与 BTI.jc 相同的 BTYPE 值兼容。 |
| 0b1  | 当 PE 在 EL2 执行时，指定的指令具有隐式 BTI 行为，它们与 BTI.c 相同的 BTYPE 值兼容。 |

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### BTO, bit [35]

当 `FEAT_BTI` 被实现且 `HCR_EL2.E2H` 的有效值为 1 时： 指示以下指令在 EL0 的隐式 BTI 行为的分支类型兼容性：

- PACIASP。
- PACIBSP。
- 如果实现了 `FEAT_PAuth_LR`，PACIASPPC。
- 如果实现了 `FEAT_PAuth_LR`，PACIBSP。

| BTO  | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0b0  | 当 PE 执行在 EL0 时，指定指令具有隐式 BTI 行为，它们与 `BTI.jc` 的相同 BTYPE 值兼容。 |
| 0b1  | 当 PE 执行在 EL0 时，指定指令具有隐式 BTI 行为，它们与 `BTI.c` 的相同 BTYPE 值兼容。 |

如果 `HCR_EL2.TGE` 等于 0b0，则除了直接读写寄存器外，该字段被忽略。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### EnFPM, bit [34]

当 `FEAT_FPMR` 被实现且 `HCR_EL2{E2H, TGE}` 的有效值为 `{1, 1}` 时： 启用从 EL0 到 EL2 的以下对 FPMR 的访问：

- 直接访问报告 EC 综合症值 0x18。
- 执行 FP8 指令导致的间接读取报告 EC 综合症值 0x00。

| EnFPM | 含义                                   |
| ----- | -------------------------------------- |
| 0b0   | EL0 对 FPMR 的访问被禁用并捕获到 EL2。 |
| 0b1   | 此控制不会导致任何指令被捕获。         |

如果有更高优先级异常生成访问，则不捕获陷阱。

如果当前安全状态下未实现或禁用了 EL2，则该字段的有效值为 0b1。

当 `HCR_EL2.TGE` 为 0 时，除了直接读写寄存器外，该字段被忽略。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### MSCEn, bit [33]

当 `FEAT_MOPS` 被实现且 `HCR_EL2.E2H` 的有效值为 1 时： 内存复制和设置指令启用。允许在 EL0 执行内存复制和设置指令。

| MSCEn | 含义                                      |
| ----- | ----------------------------------------- |
| 0b0   | 在 EL0 执行内存复制和设置指令是未定义的。 |
| 0b1   | 此控制不会使任何指令变为未定义。          |

如果 `HCR_EL2.TGE` 等于 0b0，则除了直接读写寄存器外，该字段被忽略。

当 `FEAT_MOPS` 被实现且 `HRR_EL2{E2H, TGE}` 的有效值不是 {1, 1} 时，该位的有效值为 0b1。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### CMOW, bit [32]

当 `FEAT_CMOW` 被实现且 `HCR_EL2.E2H` 的有效值为 1 时： 控制以下指令在 EL0 执行的缓存维护权限：

- IC IVAU 和 DC CIVAC。
- 如果实现了 `FEAT_MTE`，DC CIGDVAC 和 DC CIGVAC。

| CMOW | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0b0  | 这些指令在 EL0 上执行，有第一阶段读权限但没有第一阶段写权限，不会产生第一阶段权限错误。 |
| 0b1  | 如果由于 `SCTLR_EL2.UCI==1` 而启用，这些指令在 EL0 上执行，有第一阶段读权限但没有第一阶段写权限，会生成第一阶段权限错误。 |

如果 `HCR_EL2.TGE` 等于 0b0，则除了直接读写寄存器外，该字段被忽略。

对于此控制，如果满足以下所有条件，第一阶段具有写权限：

- AP[2] 是 0 或 DBM 是 1，在第一阶段描述符中。
- 当使用 APTable 时，APTable[1] 对于所有级别的转换表都是 0。
- 允许将此位缓存在 TLB 中。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### EnIA, bit [31]

当 `FEAT_PAuth` 被实现时： 控制使用 APIAKey_EL1 密钥在 EL2 或 EL2&0 转换模式下启用指针认证地址的功能。

| EnIA | 含义                                        |
| ---- | ------------------------------------------- |
| 0b0  | 使用 APIAKey_EL1 密钥的指针地址认证未启用。 |
| 0b1  | 使用 APIAKey_EL1 密钥的指针地址认证已启用。 |

此字段控制 AddPACIA 和 AuthIA 函数的行为。具体来说，当字段为 1 时，AddPACIA 返回一个带有指针认证码的指针副本，而 AuthIA 返回经过认证的指针副本。当字段为 0 时，这两个函数都为空操作（NOP）。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### EnIB, bit [30]

当 `FEAT_PAuth` 被实现时： 控制使用 APIBKey_EL1 密钥在 EL2 或 EL2&0 转换模式下启用指针认证地址的功能。

| EnIB | 含义                                        |
| ---- | ------------------------------------------- |
| 0b0  | 使用 APIBKey_EL1 密钥的指针地址认证未启用。 |
| 0b1  | 使用 APIBKey_EL1 密钥的指针地址认证已启用。 |

此字段控制 AddPACIB 和 AuthIB 函数的行为。具体来说，当字段为 1 时，AddPACIB 返回一个带有指针认证码的指针副本，而 AuthIB 返回经过认证的指针副本。当字段为 0 时，这两个函数都为空操作（NOP）。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### Lsmaoe, bit [29]

当 `FFAT_LSMOAE` 被实现且 `HCR_EL2.E2H` 的有效值为 1 时： 控制加载多个和存储多个原子性和排序功能。

| Lsmaoe | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| 0b0    | 在 EL0、A32 和 T32 下的所有内存访问可以中断序列内存访问，并且不强制要求内存访问顺序。 |
| 0b1    | A32 和 T32 在 EL0 的加载多个和存储多个顺序和中断行为与 Armv8.0 定义的一致。 |

如果 `HCR_EL2.TGE` 等于 0b0，则除了直接读写寄存器外，该字段被忽略。

此位允许缓存在 TLB 中。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES1。



### nTLSMD, bit [28]

当 `FEAT_LSMAOC` 被实现且 `HCR_EL2.E2H` 的有效值为 1 时： 控制对 Device-nGRE/Device-nGnRE/Device-nGnRnE 内存的加载多个和存储多个到设备陷阱。

| nTLSMD | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| 0b0    | 所有标记为阶段 1 Device-nGRE/Device-nGnRE/Device-nGnRnE 的 A32 和 T32 加载多个和存储多个在 EL0 的内存访问将被捕获并生成阶段 1 对齐错误。 |
| 0b1    | 所有标记为阶段 1 Device-nGRE/Device-nGnRE/Device-nGnRnE 的 A32 和 T32 加载多个和存储多个在 EL0 的内存访问不会被捕获。 |

如果 `HCR_EL2.TGE` 等于 0b0，则除了直接读写寄存器外，该字段被忽略。

此位允许缓存在 TLB 中。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES1。



### EnDA, bit [27] 

当 `FEAT_PAuth` 特性被实现时： 控制使用 `APDAKey_EL1` 密钥在 EL2 或 EL2&0 翻译模式下对数据地址进行指针认证。

| EnDA | 含义                                              |
| ---- | ------------------------------------------------- |
| 0b0  | 使用 `APDAKey_EL1` 密钥的数据地址指针认证未启用。 |
| 0b1  | 使用 `APDAKey_EL1` 密钥的数据地址指针认证已启用。 |

此字段控制 `AddPACDA` 和 `AuthDA` 伪代码函数的行为。具体来说，当该字段为 1 时，`AddPACDA` 返回一个已经添加了指针认证码的指针副本，而 `AuthDA` 返回一个经过认证的指针副本。当该字段为 0 时，这两个函数都是空操作（NOP）。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### UCI, bit [26] 

当 `HCR_EL2.E2H` 的有效值为 1 时： 捕获在 EL0 执行的缓存维护指令到 EL2，仅从 AArch64 状态，报告 EC 综合症值为 0x18，具体包括以下指令：

- `DC CVAU`, `DC CIVAC`, `DC CVAC`, 和 `IC IVAU`.
- 如果实现了 `FEAT_MTE`，还包括 `DC CIGVAC`, `DC CIGDVAC`, `DC CGVAC`, 和 `DC CGDVAC`.
- 如果实现了 `FEAT_DPB`，还包括 `DC CVAP`.
- 如果实现了 `FEAT_DPB` 和 `FEAT_MTE`，还包括 `DC CGVAP` 和 `DC CGDVAP`.
- 如果实现了 `FEAT_DPB2`，还包括 `DC CVADP`.
- 如果实现了 `FEAT_DPB2` 和 `FEAT_MTE`，还包括 `DC CGVADP` 和 `DC CGDVADP`.

| UCI  | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0b0  | 任何尝试在 EL0 使用 AArch64 执行适用于此捕获的指令都会被捕获到 EL2。 |
| 0b1  | 此控制不会导致任何指令被捕获。                               |

如果 `HCR_EL2.TGE` 等于 0b0，则除了直接读写寄存器外，该字段被忽略。

如果一致性点位于任何一级数据缓存之前，当此控制的值为 0 时，是否可以捕获任何通过虚拟地址 (VA) 操作到一致性点的数据或统一缓存清除、或清除并无效指令，由实现定义。

如果统一点位于任何一级数据缓存之前，当此控制的值为 0 时，是否可以捕获任何通过虚拟地址 (VA) 操作到统一点的数据或统一缓存清除指令，由实现定义。

如果统一点位于任何一级指令缓存之前，当此控制的值为 0 时，是否可以捕获任何通过虚拟地址 (VA) 操作到统一点的指令缓存无效指令，由实现定义。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### EE, bit [25] 

数据访问的字节序在 EL2 上，EL2 或 EL2&0 翻译模式下的第一阶段翻译表遍历，以及 EL1&0 翻译模式下的第二阶段翻译表遍历。

| EE   | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0b0  | 在 EL2 上显式的数据访问，EL2 或 EL2&0 翻译模式下的第一阶段翻译表遍历，以及 EL1&0 翻译模式下的第二阶段翻译表遍历是小端序（little-endian）。 |
| 0b1  | 在 EL2 上显式的数据访问，EL2 或 EL2&0 翻译模式下的第一阶段翻译表遍历，以及 EL1&0 翻译模式下的第二阶段翻译表遍历是大端序（big-endian）。 |

如果实现不提供高于 EL0 的异常级别上的大端序支持，此位保留为 0 (RES0)。

如果实现不提供高于 EL0 的异常级别上的小端序支持，此位保留为 1 (RES1)。

EE 位允许被缓存在 TLB（Translation Lookaside Buffer，转换后备缓冲器）中。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。



### E0E, bit [24] 

当 `HCR_EL2.E2H` 的有效值为 1 时： 控制 EL0 上数据访问的字节序。

| E0E  | 含义                                               |
| ---- | -------------------------------------------------- |
| 0b0  | 在 EL0 上显式的数据访问是小端序（little-endian）。 |
| 0b1  | 在 EL0 上显式的数据访问是大端序（big-endian）。    |

如果 `HCR_EL2.TGE` 等于 0b0，则除了直接读写寄存器之外，此字段被忽略。

如果实现只支持 EL0 上的小端序访问，则此位保留为 0 (RES0)。当 `SCTLR_EL1.EE` 为 RES1 时，不允许选择此选项。

如果实现只支持 EL0 上的大端序访问，则此位保留为 1 (RES1)。当 `SCTLR_EL1.EE` 为 RES0 时，不允许选择此选项。

此位对在 EL1 上执行的 `LDTR`, `LDTRH`, `LDTRSH`, `LDTRSW`, `STTR`, 和 `STTRH` 指令的字节序没有影响。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。



### SPAN, bit [23] 

当 `HCR_EL2.E2H` 的有效值为 1 时： 设置在进入 EL2 异常处理时的 Privileged Access Never (PAN) 标志。

| SPAN | 含义                                                  |
| ---- | ----------------------------------------------------- |
| 0b0  | 当进入 EL2 的异常处理时，将 `PSTATE.PAN` 设置为 1。   |
| 0b1  | 当进入 EL2 的异常处理时，保持 `PSTATE.PAN` 的值不变。 |

如果 `HCR_EL2.TGE` 等于 0b0，则除了直接读写寄存器之外，此字段被忽略。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES1。



### EIS, bit [22] 

当 `FEAT_ExS` 特性被实现时： 异常进入是一个上下文同步事件。

| EIS  | 含义                                  |
| ---- | ------------------------------------- |
| 0b0  | 进入 EL2 的异常不是上下文同步事件。   |
| 0b1  | 进入 EL2 的异常是一个上下文同步事件。 |

如果 `SCTLR_EL2.EIS` 被设置为 0b0：

- 对 `ESR_EL2`, `FAR_EL2`, `SPSR_EL2`, `ELR_EL2`, 和 `HPFAR_EL2` 的间接写入会在进入 EL2 时同步，因此在异常进入后直接读取这些寄存器会看到由于异常进入所引起的间接写入的值。
- 来自任何异常级别的内存事务，包括指令获取，始终使用与该翻译模式相关的翻译资源。
- 异常捕获调试事件是同步调试事件。
- `DCPS*` 和 `DRPS` 指令是上下文同步事件。

以下不受 `SCTLR_EL2.EIS` 值的影响：

- 进入 EL2 时 PSTATE 信息的变化。
- 使用 `SP` 寄存器名称进行加载、存储和数据处理指令时访问栈指针的备份副本的行为。
- 退出调试状态。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES1。



### IESB, bit [21] 

当 `FEAT_IESB` 特性被实现时： 隐式错误同步事件使能。

| IESB | 含义                       |
| ---- | -------------------------- |
| 0b0  | 禁用。                     |
| 0b1  | 添加一个隐式错误同步事件： |

- 在每次进入 EL2 的异常发生时。
- 在每个在 EL2 执行的 `ERET` 指令的操作伪代码之前。

如果实现了 `FEAT_DoubleFault2`，PE 处于非调试状态，并且 `SCTLR2_EL2.NMEA` 的有效值为 1，则 `SCTLR_EL2.IESB` 被忽略，对于除直接读取寄存器以外的所有目的，PE 的行为如同 `SCTLR_EL2.IESB` 为 1。

当 PE 处于调试状态时，此字段的效果是受限不可预测的，并且其有效值可能是 0 或 1，无论该字段的实际值如何。如果该字段的有效值为 1，则在每个进入 EL2 的 `DCPSx` 指令之后和每个在 EL2 执行的 `DRPS` 指令之前，除了上述情况外，还会添加一个隐式错误同步事件。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES1。



### TSCXT, bit [20] 

当 (`FEAT_CSV2_2` 被实现或 `FEAT_CSV2_1p2` 被实现) 并且 `HCR_EL2.E2H` 的有效值为 1 时： 捕获 EL0 访问 SCXTNUM_EL0 寄存器，当 EL0 使用 AArch64 状态时。

| TSCXT | 含义                                                         |
| ----- | ------------------------------------------------------------ |
| 0b0   | EL0 访问 SCXTNUM_EL0 不被此机制禁用。                        |
| 0b1   | EL0 访问 SCXTNUM_EL0 被禁用，导致异常进入 EL2，并且 SCXTNUM_EL0 的值被视为 0。 |

如果 `HCR_EL2.TGE` 等于 0b0，则除了直接读写寄存器之外，此字段被忽略。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

当 `FEAT_CSV2_2` 未被实现，`FEAT_CSV2_1p2` 也未被实现，并且 `HCR_EL2.{E2H, TGE}` 的有效值为 `{1, 1}` 时：

- 保留，RES1。

在其他情况下：

- 保留，RES0。



### WXN, bit [19] 

写权限意味着 XN（Execute-never）。对于 EL2 或 EL2&0 翻译模式，此位可以强制所有可写的内存区域被处理为 XN（不可执行）。

| WXN  | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0b0  | 此控制对内存访问权限没有影响。                               |
| 0b1  | 在 EL2 或 EL2&0 翻译模式下，任何可写的区域都被强制为 XN，对于从 EL2 执行的软件访问。 |

此位仅在 `SCTLR_EL2.M` 位被设置时适用。

WXN 位允许被缓存在 TLB（Translation Lookaside Buffer，转换后备缓冲器）中。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

  

### nTWE, bit [18] 

当 `HCR_EL2.E2H` 的有效值为 1 时： 捕获在 EL0 执行的 WFE 指令到 EL2，来自两种执行状态。

当 `FEAT_WFxT` 被实现时，此捕获同样适用于 WFET 指令。

| nTWE | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0b0  | 任何尝试在 EL0 执行 WFE 指令会被捕获到 EL2，如果该指令原本会导致 PE 进入低功耗状态。 |
| 0b1  | 此控制不会导致任何指令被捕获。                               |

如果 `HCR_EL2.TGE` 等于 0b0，则除了直接读写寄存器之外，此字段被忽略。

在 AArch32 状态下，尝试执行条件 WFE 指令仅在该指令通过其条件码检查时被捕获。

由于 WFE 或 WFI 可以在任何时候完成，即使没有唤醒事件，因此即使在没有唤醒事件的情况下执行 WFE 或 WFI，也不能保证捕获到 WFE 或 WFI 的陷阱。唯一的保证是，如果在没有唤醒事件的情况下指令不能在有限的时间内完成，则将捕获该陷阱。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES1。

  

### Bit [17]

保留, RES0.



### nTWI, bit [16]

当 `HCR_EL2.E2H` 的有效值为 1 时： 捕获在 EL0 执行的 WFI 指令到 EL2，来自两种执行状态。

当 `FEAT_WFxT` 被实现时，此捕获同样适用于 WFIT 指令。

| nTWI | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0b0  | 任何尝试在 EL0 执行 WFI 指令会被捕获到 EL2，如果该指令原本会导致 PE 进入低功耗状态。 |
| 0b1  | 此控制不会导致任何指令被捕获。                               |

如果 `HCR_EL2.TGE` 等于 0b0，则除了直接读写寄存器之外，此字段被忽略。

在 AArch32 状态下，尝试执行条件 WFI 指令仅在该指令通过其条件码检查时被捕获。

由于 WFE 或 WFI 可以在任何时候完成，即使没有唤醒事件，因此即使在没有唤醒事件的情况下执行 WFE 或 WFI，也不能保证捕获到 WFE 或 WFI 的陷阱。唯一的保证是，如果在没有唤醒事件的情况下指令不能在有限的时间内完成，则将捕获该陷阱。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES1。



### UCT, bit [15] 

当 `HCR_EL2.E2H` 的有效值为 1 时： 捕获 EL0 从 AArch64 状态访问 CTR_EL0 到 EL2。

| UCT  | 含义                                              |
| ---- | ------------------------------------------------- |
| 0b0  | 从 EL0 使用 AArch64 访问 CTR_EL0 会被捕获到 EL2。 |
| 0b1  | 此控制不会导致任何指令被捕获。                    |

如果 `HCR_EL2.TGE` 等于 0b0，则除了直接读写寄存器之外，此字段被忽略。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### DZE, bit [14] 

当 `HCR_EL2.E2H` 的有效值为 1 时： 捕获在 EL0 执行的 DC ZVA 指令到 EL2，仅从 AArch64 状态。

如果实现了 `FEAT_MTE`，此捕获同样适用于 DC GVA 和 DC GZVA。

| DZE  | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0b0  | 任何尝试在 EL0 使用 AArch64 执行适用于此捕获的指令都会被捕获到 EL2。从 EL0 读取 `DCZID_EL0.DZP` 返回 1，表示这些指令不受支持。 |
| 0b1  | 此控制不会导致任何指令被捕获。                               |

如果 `HCR_EL2.TGE` 等于 0b0，则除了直接读写寄存器之外，此字段被忽略。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### EnDB, bit [13] 

当 `FEAT_PAuth` 特性被实现时： 控制使用 `APDBKey_EL1` 密钥在 EL2 或 EL2&0 翻译模式下对数据地址进行指针认证。

| EnDB | 含义                                              |
| ---- | ------------------------------------------------- |
| 0b0  | 使用 `APDBKey_EL1` 密钥的数据地址指针认证未启用。 |
| 0b1  | 使用 `APDBKey_EL1` 密钥的数据地址指针认证已启用。 |

此字段控制 `AddPACDB` 和 `AuthDB` 伪代码函数的行为。具体来说，当该字段为 1 时，`AddPACDB` 返回一个已经添加了指针认证码的指针副本，而 `AuthDB` 返回一个经过认证的指针副本。当该字段为 0 时，这两个函数都是空操作（NOP）。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### I, bit [12] 

指令访问缓存控制，用于 EL2 的访问以及当 `HCR_EL2.{E2H, TGE}` 的有效值为 `{1, 1}` 时 EL0 的访问。

| I    | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0b0  | 所有从 EL2 到常规内存的指令访问对于所有级别的指令和统一缓存都是非缓存的。当 `HCR_EL2.{E2H, TGE}` 的有效值为 `{1, 1}` 时，所有从 EL0 到常规内存的指令访问对于所有级别的指令和统一缓存都是非缓存的。如果 `SCTLR_EL2.M` 为 0，则 EL2 或 EL2&0 翻译模式的第一阶段的指令访问是到常规、外部共享、内部非缓存、外部非缓存的内存。 |
| 0b1  | 此控制对从 EL2 到常规内存的指令访问的缓存性以及当 `HCR_EL2.{E2H, TGE}` 的有效值为 `{1, 1}` 时从 EL0 到常规内存的指令访问的缓存性没有影响。如果 `SCTLR_EL2.M` 的值为 0，则 EL2 或 EL2&0 翻译模式的第一阶段的指令访问是到常规、外部共享、内部写直达、外部写直达的内存。 |

此位对 EL3 翻译模式没有影响。

当 EL2 在当前安全状态下被禁用或者 `HCR_EL2.{E2H, TGE}` 的有效值不是 `{1, 1}` 时，此位对 EL1&0 翻译模式没有影响。

此字段的复位行为如下：

- 在温复位（Warm reset）情况下，在处理器进入 EL2 的系统中，此字段重置为 `'0'`。




### EOS, bit [11] 

当 `FEAT_ExS` 特性被实现时： 异常返回是一个上下文同步事件。

| EOS  | 含义                                      |
| ---- | ----------------------------------------- |
| 0b0  | 从 EL2 的异常返回不是一个上下文同步事件。 |
| 0b1  | 从 EL2 的异常返回是一个上下文同步事件。   |

如果 `SCTLR_EL2.EOS` 被设置为 0b0：

- 来自任何异常级别的内存事务，包括指令获取，始终使用与该翻译模式相关的翻译资源。
- 异常捕获调试事件是同步调试事件。
- `DCPS*` 和 `DRPS` 指令是上下文同步事件。

以下不受 `SCTLR_EL2.EOS` 值的影响：

- 在异常返回时从 `SPSR_EL2` 和 `ELR_EL2` 间接写入 PSTATE 和 PC 值是同步的。
- 使用 `SP` 寄存器名称进行加载、存储和数据处理指令时访问栈指针的备份副本的行为。
- 退出调试状态。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES1。



### Bit [9]

保留，RES0。



### SED, bit [8] 

当 EL0 能够使用 AArch32 并且 `HCR_EL2.E2H` 的有效值为 1 时： SETEND 指令禁用。在 EL0 使用 AArch32 时禁用 SETEND 指令。

| SED  | 含义                                           |
| ---- | ---------------------------------------------- |
| 0b0  | 在 EL0 使用 AArch32 时启用 SETEND 指令的执行。 |
| 0b1  | 在 EL0 使用 AArch32 时 SETEND 指令是未定义的。 |

如果 `HCR_EL2.TGE` 等于 0b0，则除了直接读写寄存器之外，此字段被忽略。

如果实现不支持任何异常级别的混合字节序操作，此位保留为 1 (RES1)。

在温复位（Warm reset）情况下，在处理器进入 EL2 的系统中，此字段重置为架构上未知的值。

当 EL0 只能使用 AArch64 并且 `HCR_EL2.E2H` 的有效值为 1 时： 如果 `HCR_EL2.TGE` 等于 0b0，则除了直接读写寄存器之外，此字段被忽略。

对此字段的访问保留为 1 (RES1)。

在其他情况下：

- 保留，RES0。




### ITD, bit [7] 

当 EL0 能够使用 AArch32 并且 `HCR_EL2.E2H` 的有效值为 1 时： IT 禁用。在 EL0 使用 AArch32 时禁用某些 IT 指令的使用。

| ITD  | 含义                                                         |
| ---- | :----------------------------------------------------------- |
| 0b0  | 在 EL0 使用 AArch32 时所有 IT 指令功能都被启用。             |
| 0b1  | 在 EL0 使用 AArch32 时尝试执行以下任何指令是未定义的：<br/>  - 所有 hw1[3:0] != 1000 的 IT 指令编码。<br/>  - 具有以下 hw1 值的后续指令：<br/>        - 0b11xxxxxxxxxxxxxx: 所有 32 位指令，以及 16 位指令 B, UDF, SVC, LDM, 和 STM。<br/>        - 0b1011xxxxxxxxxxxx: 所有“杂项 16 位指令”中的指令。<br/>        - 0b10100xxxxxxxxxxx: ADD Rd, PC, #imm<br>        - 0b0100x1xxx1111xxx: ADD Rdn, PC; CMP Rn, PC; MOV Rd, PC; BX PC; BLX PC.<br/>        - 0b010001xx1xxxx111: ADD PC, Rm; CMP PC, Rm; MOV PC, Rm. 这个模式还覆盖了 BLX Rn 的未定义情况。<br/>这些指令总是未定义的，无论它们是否会通过或失败由于处于 IT 块中而适用给它们的条件码检查。<br/>IT 指令是否被视为：<br/>   - 一个 16 位指令，只能跟另一个 16 位指令。<br/>   - 一个 32 位指令的第一部分。<br/>这意指的是，在未定义的情况下，要么第二个 16 位指令要么 32 位指令是未定义的。<br/>实现可能动态地改变 IT 是否被视为一个 16 位指令或一个 32 位指令的第一部分。 |



如果 `HCR_EL2.TGE` 等于 0b0，则除了直接读写寄存器之外，此字段被忽略。

如果 IT 块中的指令将此字段设置为 1，则行为是受限不可预测的。更多信息请参见“IT 块中的指令更改 ITD 控制”。

ITD 是可选的，但如果在 SCTLR_EL2 中实现，则也必须在 SCTLR_EL1, HSCTLR, 和 SCTLR 中实现。

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

当实现不实现 ITD 时，对此字段的访问是 RAZ/WI（读取时全零 / 写入忽略）。

当 EL0 只能使用 AArch64 并且 `HCR_EL2.E2H` 的有效值不是 1 时： 如果 `HCR_EL2.TGE` 等于 0b0，则除了直接读写寄存器之外，此字段被忽略。

在其他情况下：

- 保留，RES0。



### nAA, bit [6] 

当 `FEAT_LSE2` 特性被实现时： 非对齐访问。此位控制在特定条件下生成对齐故障，针对 EL2 和当 `HCR_EL2.{E2H, TGE}` 的有效值为 `{1, 1}` 时的 EL0。

以下指令如果访问的所有字节不在单个 16 字节块内，或者不对齐到 16 字节进行访问，则会生成对齐故障：

- LDAPR, LDAPRH, LDAPUR, LDAPURH, LDAPURSH, LDAPURSW, LDAR, LDARH, LDLAR, LDLARH.
- STLLR, STLLRH, STLR, STLRH, STLUR, STLURH.

如果实现了 `FEAT_LRCPC3`，则以下指令如果访问单个寄存器的所有字节不在单个 16 字节块内，或者不对齐到 16 字节进行访问，则会生成对齐故障：

- LDIAPP, STILP, LDAPR 的后索引版本和 STLR 的前索引版本.

如果实现了高级 SIMD 和浮点指令，则 LDAPUR (SIMD&FP), LDAP1 (SIMD&FP), STLUR (SIMD&FP), 和 STL1 (SIMD&FP) 也会受到限制。

| nAA  | 含义                                   |
| ---- | -------------------------------------- |
| 0b0  | 指定指令的非对齐访问会生成对齐故障。   |
| 0b1  | 指定指令的非对齐访问不会生成对齐故障。 |

此字段的复位行为如下：

- 在温复位 (Warm reset) 时，在系统中 PE 复位到 EL2，此字段复位为架构上未知的值。

在其他情况下：

- 保留，RES0。



### CP15BEN, bit [5] 

当 EL0 能够使用 AArch32 并且 `HCR_EL2.E2H` 的有效值为 1 时： 系统指令内存屏障使能。这使得从 EL0 可以访问 DMB (Data Memory Barrier), DSB (Data Synchronization Barrier), 和 ISB (Instruction Synchronization Barrier) 系统指令，在 coproc=0b1111 编码空间中的 CP15 指令集里：

| CP15BEN | 含义                                                         |
| ------- | ------------------------------------------------------------ |
| 0b0     | EL0 使用 AArch32: EL0 执行 CP15DMB, CP15DSB, 和 CP15ISB 指令的行为是未定义的。 |
| 0b1     | EL0 使用 AArch32: EL0 执行 CP15DMB, CP15DSB, 和 CP15ISB 指令被允许。 |

如果 `HCR_EL2.TGE` == 0b0，则该字段对于除直接读写寄存器以外的目的都是被忽略的。

CP15BEN 是可选的，但如果在 SCTLR_EL2 中实现了它，则也必须在 SCTLR_EL1, HSCTLR, 和 SCTLR 中实现。

此字段的重置行为如下：

- 在温复位（Warm reset）情况下，在处理器进入 EL2 的系统中，此字段重置为架构上未知的值。

当 EL0 只能使用 AArch64 并且 `HCR_EL2.E2H` 的有效值为 1 时： 对此字段的访问被保留为 0 (RES0)。

在其他情况下： 

- 保留，RES1。



### SA0, bit [4] 

当 `HCR_EL2.E2H` 的有效值为 1 时： EL0 的 SP 对齐检查使能。当设置为 1 时，如果在 EL0 执行的加载或存储指令使用 SP 作为基地址，并且 SP 未对齐到 16 字节边界，则会生成 SP 对齐故障异常。更多详细信息，请参阅“SP 对齐检查”。

如果 `HCR_EL2.TGE` 等于 0b0，则除了直接读写寄存器之外，此字段被忽略。

此字段的重置行为如下：

- 在温复位（Warm reset）情况下，在处理器进入 EL2 的系统中，此字段重置为架构上未知的值。

在其他情况下： 

- 保留，RES1。



### SA, bit [3] 

SP 对齐检查使能。当设置为 1 时，如果在 EL2 执行的加载或存储指令使用 SP 作为基地址，并且 SP 未对齐到 16 字节边界，则会生成 SP 对齐故障异常。更多详细信息，请参阅“SP 对齐检查”。

此字段的重置行为如下：

- 在温复位（Warm reset）情况下，在处理器进入 EL2 的系统中，此字段重置为架构上未知的值。



### C, bit [2] 

数据访问缓存控制，适用于 EL2 的访问和当 HCR_EL2.{E2H, TGE} 的有效值为 {1, 1} 时 EL0 的访问。

| C    | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0b0  | 下列操作对于所有级别的数据和统一缓存都是非缓存的：<br/> - EL2 对常规内存的数据访问。<br/> - 当 HCR_EL2.{E2H, TGE} 的有效值不是 {1, 1} 时，EL2 的翻译表对常规内存的访问。 <br/> - 当 HCR_EL2.{E2H, TGE} 的有效值为 {1, 1} 时：<br/>    - EL0 对常规内存的数据访问。<br/>    - EL2 和 EL0 的翻译表对常规内存的访问。 |
| 0b1  | 此控制对以下内容的缓存性没有影响： <br/> - EL2 对常规内存的数据访问。<br/> - 当 HCR_EL2.{E2H, TGE} 的有效值不是 {1, 1} 时，EL2 的翻译表对常规内存的访问。<br/> - 当 HCR_EL2.{E2H, TGE} 的有效值为 {1, 1} 时：<br/>    - EL0 对常规内存的数据访问。<br/>    - EL2 和 EL0 的翻译表对常规内存的访问。 |

此字段的重置行为如下：

- 在温复位（Warm reset）情况下，在处理器进入 EL2 的系统中，此字段重置为 '0'。



### A, bit [1]
对齐检查使能。这是在 EL2 执行时以及当 `HCR_EL2.{E2H, TGE}` 的有效值为 `{1, 1}` 时 EL0 执行时对齐故障检查的使能位。

| A    | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0b0  | 当在 EL2 执行时，对齐故障检查被禁用。<br/>当 `HCR_EL2.{E2H, TGE}` 的有效值为 `{1, 1}` 时，在 EL0 执行时，对齐故障检查被禁用。<br/>一些指令的对齐检查不由这个控制禁用。更多信息，请参阅“数据访问的对齐”。 |
| 0b1  | 当在 EL2 执行时，对齐故障检查被启用。<br/>当 `HCR_EL2.{E2H, TGE}` 的有效值为 `{1, 1}` 时，在 EL0 执行时，对齐故障检查被启用。<br/>所有加载或存储一个或多个寄存器的指令都有一个对齐检查，确保正在访问的地址对齐到被访问的数据元素大小。如果这个检查失败，它将导致一个对齐故障，该故障被作为数据异常异常来处理。 |

此字段的重置行为如下：

- 在温复位（Warm reset）情况下，在处理器进入 EL2 的系统中，此字段重置为架构上未知的值。



### M, bit [0]
EL2 或 EL2&0 第一阶段地址翻译的 MMU（Memory Management Unit）使能。

| M    | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0b0  | 当 `HCR_EL2.{E2H, TGE}` 的有效值不是 `{1, 1}` 时，EL2 第一阶段地址翻译被禁用。<br/>当 `HCR_EL2.{E2H, TGE}` 的有效值为 `{1, 1}` 时，EL2&0 第一阶段地址翻译被禁用。<br/>有关对常规内存的指令访问的行为，请参阅 SCTLR_EL2.I 字段。 |
| 0b1  | 当 `HCR_EL2.{E2H, TGE}` 的有效值不是 `{1, 1}` 时，EL2 第一阶段地址翻译被启用。<br/>当 `HCR_EL2.{E2H, TGE}` 的有效值为 `{1, 1}` 时，EL2&0 第一阶段地址翻译被启用。 |

此字段的重置行为如下：

- 在温复位（Warm reset）情况下，在处理器进入 EL2 的系统中，此字段重置为 `'0'`。



### 访问 SCTLR_EL2 

当 `HCR_EL2.E2H` 的有效值为 1 时，如果没有显式的同步，使用 SCTLR_EL2 或 SCTLR_EL1 访问器名称从 EL2 进行的访问不一定按照顺序相对于使用另一个访问器名称的访问。

对该寄存器的访问使用以下编码在系统寄存器编码空间中：

#### `MRS <Xt>, SCTLR_EL2`

| op0  | op1   | CRn    | CRm    | op2   |
| :--- | ----- | ------ | ------ | ----- |
| 0b11 | 0b100 | 0b0001 | 0b0000 | 0b000 |

```
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EffectiveHCR_EL2_NVx() IN {'xx1'} then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    X[t, 64] = SCTLR_EL2;
elsif PSTATE.EL == EL3 then
    X[t, 64] = SCTLR_EL2;
                
```

#### `MSR SCTLR_EL2, <Xt>`

| op0  | op1   | CRn    | CRm    | op2   |
| :--- | ----- | ------ | ------ | ----- |
| 0b11 | 0b100 | 0b0001 | 0b0000 | 0b000 |



```
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EffectiveHCR_EL2_NVx() IN {'xx1'} then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    SCTLR_EL2 = X[t, 64];
elsif PSTATE.EL == EL3 then
    SCTLR_EL2 = X[t, 64];
                
```



#### 当 FEAT_VHE 完成

#### `MRS <Xt>, SCTLR_EL1`

| op0  | op1   | CRn    | CRm    | op2   |
| :--- | ----- | ------ | ------ | ----- |
| 0b11 | 0b000 | 0b0001 | 0b0000 | 0b000 |

```
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() && HCR_EL2.TRVM == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && HFGRTR_EL2.SCTLR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EffectiveHCR_EL2_NVx() IN {'111'} then
        X[t, 64] = NVMem[0x110];
    else
        X[t, 64] = SCTLR_EL1;
elsif PSTATE.EL == EL2 then
    if ELIsInHost(EL2) then
        X[t, 64] = SCTLR_EL2;
    else
        X[t, 64] = SCTLR_EL1;
elsif PSTATE.EL == EL3 then
    X[t, 64] = SCTLR_EL1;
                
```



#### 当 FEAT_VHE 完成

#### `MSR SCTLR_EL1, <Xt>`

| op0  | op1   | CRn    | CRm    | op2   |
| :--- | ----- | ------ | ------ | ----- |
| 0b11 | 0b000 | 0b0001 | 0b0000 | 0b000 |

```
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() && HCR_EL2.TVM == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() && IsFeatureImplemented(FEAT_FGT) && (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') && HFGWTR_EL2.SCTLR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EffectiveHCR_EL2_NVx() IN {'111'} then
        NVMem[0x110] = X[t, 64];
    else
        SCTLR_EL1 = X[t, 64];
elsif PSTATE.EL == EL2 then
    if ELIsInHost(EL2) then
        SCTLR_EL2 = X[t, 64];
    else
        SCTLR_EL1 = X[t, 64];
elsif PSTATE.EL == EL3 then
    SCTLR_EL1 = X[t, 64];
                
```



[^IMPLEMENTATION DEFINED]: 在 ARM 架构文档中，“IMPLEMENTATION DEFINED”是指由特定处理器实现定义的行为。这意味着对于某些特性或寄存器位，ARM 不会规定具体的行为，而是留给处理器制造商根据其设计需求来决定如何实现。
